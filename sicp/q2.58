(define (memq iterm l)
    (cond ((null? l) false)
          ((eq? (car l) iterm) true)
          (else (memq iterm (cdr l)))
    )
)

(memq 'red '((red)))
(memq 'red '(a red sock))

(define (equal lsta lstb)
    (cond ((and (null? lsta) (null? lstb)) true)
          ((or (null? lsta) (null? lstb)) false)
          (else (if 
                  (eq? (car lsta) (car lstb)) 
                  (equal (cdr lsta) (cdr lstb)) 
                  false)
          )
    )
)

(equal '(1 2 3) '(1 2 3))

(equal '(1 2 3) '(1 2 (3)))

(define (variable? expr)
    (symbol? expr)
)

(define (same-variable? expr x)
    (and (variable? expr) (eq? expr x))
)

(define (sum? expr)
    (and (pair? expr) (eq? (car expr) '+))
)

(define (addend expr)
    (cadr expr)
)

(define (augend expr)
    (let ((left (cddr expr)))
        (if (> (length left) 1) 
            (cons '+ left)
            (car left)
        )
    )
)

(define (product? expr)
    (and (pair? expr) (eq? (car expr) '*))
)

(define (multiplier expr)
    (cadr expr)
)

(define (multiplicand expr)
    (let ((left (cddr expr)))
        (if (> (length left) 1) 
            (cons '* left)
            (car left)
        )
    )
)

(define (make-sum x y)
    (cond ((and (number? x) (number? y)) (+ x y))
          ((eq? x 0) y)
          ((eq? y 0) x)
          ((sum? y) (if (sum? x) (append x (cdr y)) (cons '+ (cons x (cdr y)))))
          ((sum? x) (append x (list y)))
          (else (list '+ x y))
    )
)

(define (make-product x y)
    (cond ((and (number? x) (number? y)) (* x y))
          ((or (eq? x 0) (eq? y 0)) 0)
          ((eq? x 1) y)
          ((eq? y 1) x)
          ((product? y) (if (product? x) (append x (cdr y)) (cons '* (cons x (cdr y)))))
          ((product? x) (append x (list y)))
          (else (list '* x y))
    )
)

(define (make-exponentiation base index)
    (cond ((and (number? index) (= index 0)) 1)
         ((and (number? index) (= index 1)) base)
         (else (list '** base index))
    )
)
(define (exponentiation? expr)
    (and (pair? expr) (eq? (car expr) '**))
)
(define (base-exponentiation expr)
    (cadr expr)
)
(define (index-exponentiation expr)
    (caddr expr)
)

(define (derive expr x)
    (cond ((number? expr) 0)
          ((variable? expr) (if (eq? expr x) 1 0))
          ((sum? expr) (make-sum (derive (addend expr) x) (derive (augend expr) x)))
          ((product? expr) (make-sum 
                            (make-product (multiplicand expr) (derive (multiplier expr) x))
                            (make-product (multiplier expr) (derive (multiplicand expr) x))))
          ((exponentiation? expr) (make-product 
                                    (index-exponentiation expr)
                                    (make-product 
                                        (make-exponentiation (base-exponentiation expr) (make-sum (index-exponentiation expr) -1)) 
                                        (derive (base-exponentiation expr) x))
                                  ))
          (else (error "unknown expression type"))
    )
)


(derive '1 'x)
(derive 'x 'x)
(define expr (make-sum 'x (make-sum 'x 'x)))
(derive expr 'x)
(define expr2 (make-product 'x 'x))
(derive (derive expr2 'x) 'x)
(make-exponentiation 'a 0)
(make-exponentiation 'a 1)
(define expr3 (make-exponentiation 'a 'n))
(exponentiation? expr3)
(base-exponentiation expr3)
(index-exponentiation expr3)
(make-sum (index-exponentiation expr3) -1)
(define expr3 (make-product 'a (make-exponentiation 'a 2)))
(derive expr3 'a)




