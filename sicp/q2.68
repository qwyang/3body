(define (make-leaf symbol weight)
    (list 'leaf symbol weight)
)
(define (leaf? tree)
    (eq? (car tree) 'leaf)
)
(define (symbol-leaf leaf)
    (cadr leaf)
)
(define (weight-leaf leaf)
    (caddr leaf)
)

;(left-tree right-tree symbols weight)
(define (make-code-tree left right)
    (list left right
        (append (symbols left) (symbols right))
        (+ (weight left) (weight right))
    )
)

(define (symbols tree)
    (if (leaf? tree) 
        (list (symbol-leaf tree))
        (caddr tree)
    )
)

(define (weight tree)
    (if (leaf? tree)
        (weight-leaf tree)
        (cadddr tree)
    )
)


(define (choose-branch b tree)
    (cond ((= b 0) (car tree))
          ((= b 1) (cadr tree))
          (else (error "not 0 or 1"))
    )
)

(define (decode bits tree)
    (define (decode-1 binary current-branch)
        (if (null? binary) 
            '()
            (let ((next-branch 
                   (choose-branch (car binary) current-branch)))
                (if (leaf? next-branch) 
                    ;next-branch
                    ;(symbol-leaf next-branch)
                    (cons (symbol-leaf next-branch) 
                        (decode-1 (cdr binary) tree))
                    (decode-1 (cdr binary) next-branch)
                )
            )
        )
    )
    (decode-1 bits tree)
)

(define (adjoin-set t set)
    (cond ((null? set) (list t))
          ((< (weight t) (weight (car set))) (cons t set))
          (else (cons (car set) (adjoin-set t (cdr set))))
    )
)
;(A 4) (B 2) (C 1) (D 1)
(define (make-leaf-set pairs)
    (if (null? pairs)
        ()
        (let ((pair (car pairs)))
            (adjoin-set 
                (make-leaf (car pair) (cadr pair)) 
                (make-leaf-set (cdr pairs))
            )
        )
    )
)

(define sample-tree
    (make-code-tree (make-leaf 'A 4) 
                    (make-code-tree 
                        (make-leaf 'B 2) 
                        (make-code-tree 
                            (make-leaf 'D 1) 
                            (make-leaf 'C 1)
                        )
                   )
    )
)

(define sample-tree (make-code-tree 
                        (make-leaf 'B 2) 
                        (make-code-tree 
                            (make-leaf 'D 1) 
                            (make-leaf 'C 1)
                        )
                   ))
;(encode-symbol sym tree) = (encode-symbol sym left-branch) + (encode-symbol sym right-branch)
;if (leaf? tree) (true result)
(define (encode-symbol sym tree)
    (define (iter sym tree result)
        (if (leaf? tree) 
            (if (eq? (symbol-leaf tree) sym) 
                result
                ()
            )
            (append (iter sym (choose-branch 0 tree) (cons 0 result))
               (iter sym (choose-branch 1 tree) (cons 1 result)))
        )
    )
    (reverse (iter sym tree ()))
)

(define (encode message tree)
    (if (null? message)
        ()
        (append (encode-symbol (car message) tree) (encode (cdr message) tree))
    )
)

(define pairs '((A 4) (B 2) (C 1) (D 1)))
(make-leaf-set pairs)
(define message '(0));A
(decode message sample-tree)
(define message '(1));()
(decode message sample-tree)
(define message '(1 0));B
(decode message sample-tree)
(define message '(1 1));A D
(decode message sample-tree)
(define message '(1 1 1))
(decode message sample-tree)
(define message '(0 1 1 0));A D A B B C A
(decode message sample-tree)
(define message '(0 1 1 0 0 1 0 1 0 1 1 1 0));A D A B B C A
(decode message sample-tree)
(encode-symbol 'b sample-tree)
(encode-symbol 'c sample-tree)
(encode-symbol 'd sample-tree)

(encode '(a b c d) sample-tree)
